import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { ChangeDetectionStrategy, Component, ContentChild, ContentChildren, ElementRef, forwardRef, Inject, Input, PLATFORM_ID, ViewChild, ViewContainerRef, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { BehaviorSubject, forkJoin, fromEvent, interval, merge, of, Subject, timer, } from 'rxjs';
import { bufferCount, filter, switchMap, takeUntil, tap } from 'rxjs/operators';
import { NgxHmCarouselItemDirective } from './ngx-hm-carousel-item.directive';
import { resizeObservable } from './rxjs.observable.resize';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class NgxHmCarouselComponent {
    constructor(platformId, _document, _renderer, _zone, _cd) {
        this.platformId = platformId;
        this._document = _document;
        this._renderer = _renderer;
        this._zone = _zone;
        this._cd = _cd;
        /** when infinite is true, the animation time with item, default is 400. */
        this.aniTime = 400;
        /** this class will add in #containerElm when model change */
        this.aniClass = 'transition';
        /** this class will add when carousel auto play,
         * this default autoplay animation is same as aniClass
         */
        this.aniClassAuto = this.aniClass;
        /**
         * user move picture with the container width rate,
         * when more than that rate, it will go to next or prev,
         * set false will never move with distance rate,
         * default is `0.15`
         */
        this.panBoundary = 0.15;
        /** when `show-num` is bigger than 1, the first item align, default is `center` */
        this.align = 'center';
        /**
         * disable when drag occur the child element will follow touch point.
         * default is `false`
         */
        this.notDrag = false;
        /**
         * the event binding state for stop auto play when mouse moveover
         */
        this.mouseEnable = false;
        /** each auto play between time */
        this.delay = 8000;
        /** auto play direction, default is `right`. */
        this.direction = 'right';
        /** how many number with each scroll, default is `1`. */
        this.scrollNum = 1;
        /** Could user scroll many item once, simulate with scrollbar, default is `false` */
        this.isDragMany = false;
        /** Minimal velocity required before recognizing, unit is in px per ms, default `0.3` */
        this.swipeVelocity = 0.3;
        /**
         * switch show number with custom logic like css @media (min-width: `number`px)
         */
        this.breakpoint = [];
        // using for check mouse or touchend
        this.leaveObs$ = merge(fromEvent(this._document, 'mouseup'), fromEvent(this._document, 'touchend')).pipe(tap((e) => {
            this.grabbing = false;
            e.stopPropagation();
            e.preventDefault();
        }));
        this.isFromAuto = true;
        this.isAutoNum = false;
        this.mouseOnContainer = false;
        this.alignDistance = 0;
        this.elmWidth = 0;
        this.infiniteElmRefs = [];
        this.restart = new BehaviorSubject(null);
        this.speedChange = new BehaviorSubject(5000);
        this.stopEvent = new Subject();
        this.destroy$ = new Subject();
        this._progressWidth = 0;
        this._currentIndex = 0;
        this._showNum = 1;
        this._autoplay = false;
        this._infinite = false;
        this._tmpInfinite = false;
        this._grabbing = false;
        this._disableDrag = false;
        this.panCount = 0;
        // this variable use for check the init value is write with ngModel,
        // when init first, not set with animation
        this.hasInitWriteValue = false;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    /** disable drag event with touch and mouse pan moving, default is `false` */
    get disableDrag() {
        return this._disableDrag;
    }
    set disableDrag(value) {
        if (this.rootElm) {
            if (this._disableDrag !== value) {
                if (value) {
                    this.destroyHammer();
                }
                else {
                    this.hammer = this.bindHammer();
                }
            }
        }
        this._disableDrag = value;
    }
    /** is the carousel can move infinite */
    get infinite() {
        return this._infinite;
    }
    set infinite(value) {
        this._infinite = value;
        this.infiniteElmRefs.forEach((ref) => {
            this.addStyle(ref.rootNodes[0], {
                visibility: this.runLoop ? 'visible' : 'hidden',
            });
        });
    }
    /** auto play speed */
    get speed() {
        return this.speedChange.value;
    }
    set speed(value) {
        this._zone.runOutsideAngular(() => {
            this.speedChange.next(value);
        });
    }
    /**
     * how many number items to show once, default is `1`
     * set `auto` to using `[breakpoint]` set value.
     */
    get showNum() {
        return this._showNum;
    }
    set showNum(value) {
        if (value === 'auto') {
            this.isAutoNum = true;
        }
        else {
            this._showNum = +value;
            if (this.rootElm) {
                this.setViewWidth();
                this.reSetAlignDistance();
            }
        }
    }
    /** is that carousel auto play */
    get autoplay() {
        return this._autoplay;
    }
    set autoplay(value) {
        if (isPlatformBrowser(this.platformId)) {
            if (this.elms) {
                this.progressWidth = 0;
                if (value) {
                    this._zone.runOutsideAngular(() => {
                        this.doNextSub$ = this.doNext.subscribe();
                    });
                }
                else {
                    if (this.doNextSub$) {
                        this.doNextSub$.unsubscribe();
                    }
                }
            }
        }
        this._autoplay = value;
        // if set autoplay, then the infinite is true
        if (value) {
            this._tmpInfinite = this.infinite;
            this.infinite = true;
        }
        else {
            this.infinite = this._tmpInfinite;
        }
    }
    get currentIndex() {
        return this._currentIndex;
    }
    set currentIndex(value) {
        // if now index is not equal to save index, do something
        if (this.currentIndex !== value) {
            // if the value is not contain with the boundary not handler
            if (!this.runLoop && !(0 <= value && value <= this.itemElms.length - 1)) {
                return;
            }
            this._currentIndex = value;
            if (this.elms) {
                if (this.autoplay && !this.isFromAuto) {
                    this._zone.runOutsideAngular(() => {
                        this.stopEvent.next();
                        this.callRestart();
                    });
                }
                this.drawView(this.currentIndex, this.hasInitWriteValue);
                if (this.isDragMany) {
                    this.hasInitWriteValue = true;
                }
            }
            if (0 <= this.currentIndex &&
                this.currentIndex <= this.itemElms.length - 1) {
                this._zone.run(() => {
                    this.onChange(this.currentIndex);
                    this._cd.detectChanges();
                });
            }
        }
        this.isFromAuto = false;
    }
    get progressWidth() {
        return this._progressWidth;
    }
    set progressWidth(value) {
        if (this.progressElm !== undefined && this.autoplay) {
            this._progressWidth = value;
            this._renderer.setStyle(this.progressContainerElm.nativeElement.children[0], 'width', `${this.progressWidth}%`);
        }
    }
    get grabbing() {
        return this._grabbing;
    }
    set grabbing(value) {
        if (this._grabbing !== value) {
            // console.log(value);
            this._zone.run(() => {
                this._grabbing = value;
                if (value) {
                    this._renderer.addClass(this.containerElm, 'grabbing');
                }
                else {
                    this.panCount = 0;
                    this.callRestart();
                    this._renderer.removeClass(this.containerElm, 'grabbing');
                }
                this._cd.detectChanges();
            });
        }
    }
    set left(value) {
        if (isPlatformBrowser(this.platformId)) {
            this._renderer.setStyle(this.containerElm, 'transform', `translateX(${value}px)`);
        }
        else {
            this._renderer.setStyle(this.containerElm, 'transform', `translateX(${value}%)`);
        }
    }
    get maxRightIndex() {
        let addIndex = 0;
        switch (this.align) {
            case 'left':
                addIndex = 0;
                break;
            case 'center':
                addIndex = this.showNum - 1;
                break;
            case 'right':
                addIndex = this.showNum - 1;
                break;
        }
        return this.itemElms.length - 1 - this._showNum + 1 + addIndex;
    }
    get runLoop() {
        return this.autoplay || this.infinite;
    }
    get lengthOne() {
        return this.itemElms.length === 1;
    }
    get rootElmWidth() {
        return isPlatformBrowser(this.platformId)
            ? this.rootElm.getBoundingClientRect().width
            : 100;
    }
    set containerElmWidth(value) {
        this.setStyle(this.containerElm, 'width', value);
    }
    ngAfterViewInit() {
        this.rootElm = this.container.nativeElement;
        this.containerElm = this.rootElm.children[0];
        this.init();
        forkJoin([
            this.bindClick(),
            // when item changed, remove old hammer binding, and reset width
            this.itemElms.changes.pipe(
            // detectChanges to change view dots
            tap(() => {
                if (this.currentIndex > this.itemElms.length - 1) {
                    // i can't pass the change detection check, only the way to using timeout. :(
                    setTimeout(() => {
                        this.currentIndex = this.itemElms.length - 1;
                    }, 0);
                }
                this.destroy();
                this.removeInfiniteElm();
                this.init();
                this.progressWidth = 0;
            }), tap(() => this._cd.detectChanges())),
            resizeObservable(this.rootElm, () => this.containerResize()),
        ])
            .pipe(takeUntil(this.destroy$))
            .subscribe();
    }
    ngOnDestroy() {
        this.destroy();
        this.destroy$.next();
        this.destroy$.unsubscribe();
    }
    writeValue(value) {
        if (value || value === 0) {
            this.currentIndex = value;
            this.hasInitWriteValue = true;
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    init() {
        this.initVariable();
        this.setViewWidth(true);
        this.reSetAlignDistance();
        if (!this.disableDrag) {
            this.hammer = this.bindHammer();
        }
        this.drawView(this.currentIndex, false);
        if (isPlatformBrowser(this.platformId) && this.runLoop) {
            this.addInfiniteElm();
        }
    }
    destroy() {
        this.destroyHammer();
        if (this.autoplay) {
            this.doNextSub$.unsubscribe();
        }
    }
    destroyHammer() {
        if (this.hammer) {
            this.hammer.destroy();
        }
    }
    addInfiniteElm() {
        for (let i = 1; i <= this.showNum; i++) {
            const elm = this.infiniteContainer.createEmbeddedView(this.contentContent, {
                $implicit: this.data[this.itemElms.length - i],
                index: this.itemElms.length - i,
            });
            this.addStyle(elm.rootNodes[0], {
                position: 'absolute',
                // boxShadow: `0 0 0 5000px rgba(200, 75, 75, 0.5) inset`,
                transform: `translateX(-${100 * i}%)`,
                visibility: this.runLoop ? 'visible' : 'hidden',
            });
            this.setStyle(elm.rootNodes[0], 'width', this.elmWidth);
            const elm2 = this.infiniteContainer.createEmbeddedView(this.contentContent, {
                $implicit: this.data[i - 1],
                index: i - 1,
            });
            this.addStyle(elm2.rootNodes[0], {
                // boxShadow: `0 0 0 5000px rgba(200, 75, 75, 0.5) inset`,
                position: 'absolute',
                right: 0,
                top: 0,
                transform: `translateX(${100 * i}%)`,
                visibility: this.runLoop ? 'visible' : 'hidden',
            });
            this.setStyle(elm2.rootNodes[0], 'width', this.elmWidth);
            elm.detectChanges();
            elm2.detectChanges();
            this.infiniteElmRefs.push(elm);
            this.infiniteElmRefs.push(elm2);
        }
    }
    removeInfiniteElm() {
        this.infiniteElmRefs.forEach((a) => {
            a.detach();
            a.destroy();
        });
        if (this.infiniteContainer) {
            this.infiniteContainer.clear();
        }
        this.infiniteElmRefs = [];
    }
    containerResize() {
        this.setViewWidth();
        this.reSetAlignDistance();
        const touchEnd = this.showNum >= this.elms.length;
        if (this.align !== 'center' && touchEnd) {
            this.currentIndex = 0;
        }
        this.drawView(this.currentIndex, false);
    }
    initVariable() {
        this._zone.runOutsideAngular(() => {
            this.elms = this.itemElms.toArray().map((x) => x.nativeElement);
            let startEvent = this.restart.asObservable();
            let stopEvent = this.stopEvent.asObservable();
            if (this.mouseEnable) {
                startEvent = merge(startEvent, fromEvent(this.containerElm, 'mouseleave').pipe(
                // when leave, we should reverse grabbing state to set the mouseOn state,
                // because when the grabbing, the mask will on, and it will occur leave again
                filter(() => !this.grabbing), tap(() => (this.mouseOnContainer = false))));
                stopEvent = merge(stopEvent, fromEvent(this.containerElm, 'mouseover').pipe(tap(() => (this.mouseOnContainer = true))));
            }
            this.doNext = startEvent.pipe(
            // not using debounceTime, it will stop mouseover event detect, will cause mouse-enable error
            // debounceTime(this.delay),
            switchMap(() => this.speedChange), switchMap(() => timer(this.delay).pipe(switchMap(() => this.runProgress(20)), tap(() => {
                this.isFromAuto = true;
                // console.log('next');
                if (this.direction === 'left') {
                    this.currentIndex -= this.scrollNum;
                }
                else {
                    this.currentIndex += this.scrollNum;
                }
            }), takeUntil(stopEvent.pipe(tap(() => (this.progressWidth = 0)))))));
            if (this.autoplay) {
                this.doNextSub$ = this.doNext.subscribe();
            }
        });
    }
    reSetAlignDistance() {
        switch (this.align) {
            case 'center':
                this.alignDistance = (this.rootElmWidth - this.elmWidth) / 2;
                break;
            case 'left':
                this.alignDistance = 0;
                break;
            case 'right':
                this.alignDistance = this.rootElmWidth - this.elmWidth;
                break;
        }
    }
    setViewWidth(isInit) {
        if (this.isAutoNum) {
            this._showNum = this.getAutoNum();
        }
        this._renderer.addClass(this.containerElm, 'grab');
        if (isInit) {
            // remain one elm height
            this._renderer.addClass(this.containerElm, 'ngx-hm-carousel-display-nowrap');
        }
        this.elmWidth = this.rootElmWidth / this._showNum;
        this._renderer.removeClass(this.containerElm, 'ngx-hm-carousel-display-nowrap');
        this.containerElmWidth = this.elmWidth * this.elms.length;
        this._renderer.setStyle(this.containerElm, 'position', 'relative');
        this.infiniteElmRefs.forEach((ref) => {
            this.setStyle(ref.rootNodes[0], 'width', this.elmWidth);
        });
        this.elms.forEach((elm) => {
            this.setStyle(elm, 'width', this.elmWidth);
        });
    }
    bindHammer() {
        if (!isPlatformBrowser(this.platformId)) {
            return null;
        }
        return this._zone.runOutsideAngular(() => {
            const hm = new Hammer.Manager(this.containerElm);
            const pan = new Hammer.Pan({
                direction: Hammer.DIRECTION_HORIZONTAL,
                threshold: 0,
            });
            hm.add(pan);
            hm.on('panleft panright panend pancancel', (e) => {
                // console.log(e.type);
                if (this.lengthOne) {
                    return;
                }
                this.removeContainerTransition();
                if (this.autoplay) {
                    this._zone.runOutsideAngular(() => {
                        this.stopEvent.next();
                    });
                }
                switch (e.type) {
                    case 'panleft':
                    case 'panright':
                        this.panCount++;
                        // only when panmove more than two times, set move
                        if (this.panCount < 2) {
                            return;
                        }
                        this.grabbing = true;
                        // When show-num is bigger than length, stop hammer
                        if (this.align !== 'center' && this.showNum >= this.elms.length) {
                            this.hammer.stop(true);
                            return;
                        }
                        // Slow down at the first and last pane.
                        if (!this.runLoop && this.outOfBound(e.type)) {
                            e.deltaX *= 0.2;
                        }
                        if (!this.notDrag) {
                            this.left =
                                -this.currentIndex * this.elmWidth +
                                    this.alignDistance +
                                    e.deltaX;
                        }
                        //  if not drag many, when bigger than half
                        if (!this.isDragMany) {
                            if (Math.abs(e.deltaX) > this.elmWidth * 0.5) {
                                if (e.deltaX > 0) {
                                    this.currentIndex -= this.scrollNum;
                                }
                                else {
                                    this.currentIndex += this.scrollNum;
                                }
                                this.hammer.stop(true);
                                return;
                            }
                        }
                        break;
                    case 'pancancel':
                        this.drawView(this.currentIndex);
                        break;
                    case 'panend':
                        // if boundary more than rate
                        if (this.panBoundary !== false &&
                            Math.abs(e.deltaX) > this.elmWidth * this.panBoundary) {
                            const moveNum = this.isDragMany
                                ? Math.ceil(Math.abs(e.deltaX) / this.elmWidth)
                                : this.scrollNum;
                            const prevIndex = this.currentIndex - moveNum;
                            const nextIndex = this.currentIndex + moveNum;
                            // if right
                            if (e.deltaX > 0) {
                                this.goPrev(prevIndex);
                                // left
                            }
                            else {
                                this.goNext(nextIndex);
                            }
                            break;
                        }
                        else if (e.velocityX < -this.swipeVelocity && e.distance > 10) {
                            this.goNext(this.currentIndex + this.scrollNum);
                        }
                        else if (e.velocityX > this.swipeVelocity && e.distance > 10) {
                            this.goPrev(this.currentIndex - this.scrollNum);
                        }
                        else {
                            this.drawView(this.currentIndex);
                        }
                        break;
                }
            });
            return hm;
        });
    }
    goPrev(prevIndex) {
        if (!this.runLoop && prevIndex < 0) {
            prevIndex = 0;
            this.drawView(0);
        }
        this.currentIndex = prevIndex;
    }
    goNext(nextIndex) {
        if (!this.runLoop && nextIndex > this.maxRightIndex) {
            nextIndex = this.maxRightIndex;
            this.drawView(nextIndex);
        }
        this.currentIndex = nextIndex;
    }
    bindClick() {
        if (this.btnNext && this.btnPrev) {
            return forkJoin([
                fromEvent(this.btnNext.nativeElement, 'click').pipe(tap(() => this.currentIndex++)),
                fromEvent(this.btnPrev.nativeElement, 'click').pipe(tap(() => this.currentIndex--)),
            ]);
        }
        return of(null);
    }
    callRestart() {
        // if that is autoplay
        // if that mouse is not on container( only mouse-enable is true, the state maybe true)
        // if now is grabbing, skip this restart, using grabbing change restart
        if (this.autoplay && !this.mouseOnContainer && !this.grabbing) {
            this._zone.runOutsideAngular(() => {
                this.restart.next(null);
            });
        }
    }
    drawView(index, isAnimation = true, isFromAuto = this.isFromAuto) {
        // move element only on length is more than 1
        if (this.elms.length > 1) {
            this.removeContainerTransition();
            this.left = -(index * this.elmWidth - this.alignDistance);
            if (isAnimation) {
                if (isFromAuto) {
                    this._renderer.addClass(this.containerElm, this.aniClassAuto);
                }
                else {
                    this._renderer.addClass(this.containerElm, this.aniClass);
                }
                // if infinite move to next index with timeout
                this.infiniteHandler(index);
            }
        }
        else {
            this.left = this.alignDistance;
        }
    }
    removeContainerTransition() {
        this._renderer.removeClass(this.containerElm, this.aniClass);
        this._renderer.removeClass(this.containerElm, this.aniClassAuto);
    }
    infiniteHandler(index) {
        if (this.runLoop) {
            let state = 0;
            state = index < 0 ? -1 : state;
            state = index > this.itemElms.length - 1 ? 1 : state;
            // index = index % this._showNum;
            if (state !== 0) {
                switch (state) {
                    case -1:
                        this._currentIndex =
                            (this.itemElms.length + index) % this.itemElms.length;
                        break;
                    case 1:
                        this._currentIndex = index % this.itemElms.length;
                        break;
                }
                const isFromAuto = this.isFromAuto;
                if (this.saveTimeOut) {
                    this.saveTimeOut.unsubscribe();
                }
                this.saveTimeOut = timer(this.aniTime)
                    .pipe(switchMap(() => {
                    // if it is any loop carousel, the next event need wait the timeout complete
                    if (this.aniTime === this.speed) {
                        this.removeContainerTransition();
                        this.left =
                            -((this._currentIndex - state) * this.elmWidth) +
                                this.alignDistance;
                        return timer(50).pipe(tap(() => {
                            this.drawView(this.currentIndex, this.hasInitWriteValue, isFromAuto);
                        }));
                    }
                    else {
                        this.drawView(this.currentIndex, false);
                    }
                    return of(null);
                }), takeUntil(this.stopEvent))
                    .subscribe();
            }
        }
    }
    outOfBound(type) {
        switch (type) {
            case 'panleft':
                return this.currentIndex >= this.maxRightIndex;
            case 'panright':
                return this.currentIndex <= 0;
        }
    }
    runProgress(betweenTime) {
        return this._zone.runOutsideAngular(() => {
            const howTimes = this.speed / betweenTime;
            const everyIncrease = (100 / this.speed) * betweenTime;
            return interval(betweenTime).pipe(tap((t) => {
                this.progressWidth = (t % howTimes) * everyIncrease;
            }), bufferCount(Math.round(howTimes), 0));
        });
    }
    getAutoNum() {
        const currWidth = this.rootElmWidth;
        // check user has had set breakpoint
        if (this.breakpoint.length > 0) {
            // get the last biggest point
            const now = this.breakpoint.find((b) => {
                return b.width >= currWidth;
            });
            // if find value, it is current width
            if (now) {
                return now.number;
            }
            return this.breakpoint[this.breakpoint.length - 1].number;
        }
        // system init show number
        const initNum = 3;
        // 610
        if (currWidth > 300) {
            return Math.floor(initNum + currWidth / 200);
        }
        return initNum;
    }
    addStyle(elm, style) {
        if (style) {
            Object.keys(style).forEach((key) => {
                const value = style[key];
                this._renderer.setStyle(elm, key, value);
            });
        }
    }
    setStyle(elm, style, value) {
        if (isPlatformBrowser(this.platformId)) {
            this._renderer.setStyle(elm, style, `${value}px`);
        }
        else {
            this._renderer.setStyle(elm, style, `${value}%`);
        }
    }
}
NgxHmCarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.1", ngImport: i0, type: NgxHmCarouselComponent, deps: [{ token: PLATFORM_ID }, { token: DOCUMENT }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
NgxHmCarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.0.1", type: NgxHmCarouselComponent, selector: "ngx-hm-carousel", inputs: { data: "data", aniTime: "aniTime", aniClass: "aniClass", aniClassAuto: "aniClassAuto", panBoundary: ["pan-boundary", "panBoundary"], align: "align", notDrag: ["not-follow-pan", "notDrag"], mouseEnable: ["mouse-enable", "mouseEnable"], delay: ["between-delay", "delay"], direction: ["autoplay-direction", "direction"], scrollNum: ["scroll-num", "scrollNum"], isDragMany: ["drag-many", "isDragMany"], swipeVelocity: ["swipe-velocity", "swipeVelocity"], breakpoint: "breakpoint", disableDrag: ["disable-drag", "disableDrag"], infinite: "infinite", speed: ["autoplay-speed", "speed"], showNum: ["show-num", "showNum"], autoplay: "autoplay" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => NgxHmCarouselComponent),
            multi: true,
        },
    ], queries: [{ propertyName: "contentPrev", first: true, predicate: ["carouselPrev"], descendants: true }, { propertyName: "contentNext", first: true, predicate: ["carouselNext"], descendants: true }, { propertyName: "dotElm", first: true, predicate: ["carouselDot"], descendants: true }, { propertyName: "progressElm", first: true, predicate: ["carouselProgress"], descendants: true }, { propertyName: "infiniteContainer", first: true, predicate: ["infiniteContainer"], descendants: true, read: ViewContainerRef }, { propertyName: "contentContent", first: true, predicate: ["carouselContent"], descendants: true }, { propertyName: "itemElms", predicate: NgxHmCarouselItemDirective, descendants: true, read: ElementRef }], viewQueries: [{ propertyName: "container", first: true, predicate: ["containerElm"], descendants: true }, { propertyName: "btnPrev", first: true, predicate: ["prev"], descendants: true }, { propertyName: "btnNext", first: true, predicate: ["next"], descendants: true }, { propertyName: "progressContainerElm", first: true, predicate: ["progress"], descendants: true }], ngImport: i0, template: "<div #containerElm class=\"carousel\">\n  <!-- main content -->\n  <ng-content select=\"[ngx-hm-carousel-container]\"></ng-content>\n  <!-- left -->\n  <div #prev *ngIf=\"contentPrev\" class=\"direction left\">\n    <ng-container *ngTemplateOutlet=\"contentPrev\"></ng-container>\n  </div>\n  <!--  right -->\n  <div #next *ngIf=\"contentNext\" class=\"direction right\">\n    <ng-container *ngTemplateOutlet=\"contentNext\"></ng-container>\n  </div>\n  <!-- indicators -->\n  <ul class=\"indicators\" *ngIf=\"dotElm\">\n    <li *ngFor=\"let dot of itemElms; let i = index\" (click)=\"currentIndex = i\">\n      <ng-container\n        *ngTemplateOutlet=\"\n          dotElm;\n          context: {\n            $implicit: {\n              index: i,\n              currentIndex: currentIndex\n            }\n          }\n        \"\n      >\n      </ng-container>\n    </li>\n  </ul>\n  <!-- progress -->\n  <div *ngIf=\"progressElm && autoplay\" #progress>\n    <ng-container *ngTemplateOutlet=\"progressElm\"> </ng-container>\n  </div>\n\n  <div class=\"mask\" *ngIf=\"grabbing\">\n    <ng-container *ngIf=\"leaveObs$ | async\"></ng-container>\n  </div>\n</div>\n", styles: [":host{display:block;height:100%}.ngx-hm-carousel-display-nowrap{display:flex!important;flex-wrap:nowrap!important;flex-direction:row!important;overflow:hidden!important}.carousel{overflow:hidden;position:relative;width:100%;height:100%}.carousel ul.indicators{list-style:none;bottom:1rem;left:0;margin:0;padding:0;position:absolute;text-align:center;width:100%}.carousel ul.indicators li{cursor:pointer;display:inline-block;position:relative;padding:.5rem}.carousel .direction{position:absolute;height:100%;cursor:pointer;display:flex;align-items:center;justify-content:center;top:0}.carousel .direction.left{left:0}.carousel .direction.right{position:absolute;right:0}.grab{cursor:grab}.grabbing{cursor:grabbing}.mask{position:absolute;left:0;top:0;right:0;bottom:0}\n"], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i1.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.1", ngImport: i0, type: NgxHmCarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-hm-carousel', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => NgxHmCarouselComponent),
                            multi: true,
                        },
                    ], changeDetection: ChangeDetectionStrategy.OnPush, template: "<div #containerElm class=\"carousel\">\n  <!-- main content -->\n  <ng-content select=\"[ngx-hm-carousel-container]\"></ng-content>\n  <!-- left -->\n  <div #prev *ngIf=\"contentPrev\" class=\"direction left\">\n    <ng-container *ngTemplateOutlet=\"contentPrev\"></ng-container>\n  </div>\n  <!--  right -->\n  <div #next *ngIf=\"contentNext\" class=\"direction right\">\n    <ng-container *ngTemplateOutlet=\"contentNext\"></ng-container>\n  </div>\n  <!-- indicators -->\n  <ul class=\"indicators\" *ngIf=\"dotElm\">\n    <li *ngFor=\"let dot of itemElms; let i = index\" (click)=\"currentIndex = i\">\n      <ng-container\n        *ngTemplateOutlet=\"\n          dotElm;\n          context: {\n            $implicit: {\n              index: i,\n              currentIndex: currentIndex\n            }\n          }\n        \"\n      >\n      </ng-container>\n    </li>\n  </ul>\n  <!-- progress -->\n  <div *ngIf=\"progressElm && autoplay\" #progress>\n    <ng-container *ngTemplateOutlet=\"progressElm\"> </ng-container>\n  </div>\n\n  <div class=\"mask\" *ngIf=\"grabbing\">\n    <ng-container *ngIf=\"leaveObs$ | async\"></ng-container>\n  </div>\n</div>\n", styles: [":host{display:block;height:100%}.ngx-hm-carousel-display-nowrap{display:flex!important;flex-wrap:nowrap!important;flex-direction:row!important;overflow:hidden!important}.carousel{overflow:hidden;position:relative;width:100%;height:100%}.carousel ul.indicators{list-style:none;bottom:1rem;left:0;margin:0;padding:0;position:absolute;text-align:center;width:100%}.carousel ul.indicators li{cursor:pointer;display:inline-block;position:relative;padding:.5rem}.carousel .direction{position:absolute;height:100%;cursor:pointer;display:flex;align-items:center;justify-content:center;top:0}.carousel .direction.left{left:0}.carousel .direction.right{position:absolute;right:0}.grab{cursor:grab}.grabbing{cursor:grabbing}.mask{position:absolute;left:0;top:0;right:0;bottom:0}\n"] }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { container: [{
                type: ViewChild,
                args: ['containerElm']
            }], btnPrev: [{
                type: ViewChild,
                args: ['prev']
            }], btnNext: [{
                type: ViewChild,
                args: ['next']
            }], progressContainerElm: [{
                type: ViewChild,
                args: ['progress']
            }], itemElms: [{
                type: ContentChildren,
                args: [NgxHmCarouselItemDirective, {
                        read: ElementRef,
                        descendants: true,
                    }]
            }], contentPrev: [{
                type: ContentChild,
                args: ['carouselPrev']
            }], contentNext: [{
                type: ContentChild,
                args: ['carouselNext']
            }], dotElm: [{
                type: ContentChild,
                args: ['carouselDot']
            }], progressElm: [{
                type: ContentChild,
                args: ['carouselProgress']
            }], infiniteContainer: [{
                type: ContentChild,
                args: ['infiniteContainer', { read: ViewContainerRef }]
            }], contentContent: [{
                type: ContentChild,
                args: ['carouselContent']
            }], data: [{
                type: Input
            }], aniTime: [{
                type: Input
            }], aniClass: [{
                type: Input
            }], aniClassAuto: [{
                type: Input
            }], panBoundary: [{
                type: Input,
                args: ['pan-boundary']
            }], align: [{
                type: Input
            }], notDrag: [{
                type: Input,
                args: ['not-follow-pan']
            }], mouseEnable: [{
                type: Input,
                args: ['mouse-enable']
            }], delay: [{
                type: Input,
                args: ['between-delay']
            }], direction: [{
                type: Input,
                args: ['autoplay-direction']
            }], scrollNum: [{
                type: Input,
                args: ['scroll-num']
            }], isDragMany: [{
                type: Input,
                args: ['drag-many']
            }], swipeVelocity: [{
                type: Input,
                args: ['swipe-velocity']
            }], breakpoint: [{
                type: Input
            }], disableDrag: [{
                type: Input,
                args: ['disable-drag']
            }], infinite: [{
                type: Input,
                args: ['infinite']
            }], speed: [{
                type: Input,
                args: ['autoplay-speed']
            }], showNum: [{
                type: Input,
                args: ['show-num']
            }], autoplay: [{
                type: Input,
                args: ['autoplay']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWhtLWNhcm91c2VsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1obS1jYXJvdXNlbC9zcmMvbGliL25neC1obS1jYXJvdXNlbC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtaG0tY2Fyb3VzZWwvc3JjL2xpYi9uZ3gtaG0tY2Fyb3VzZWwuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzlELE9BQU8sRUFFTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUNULFlBQVksRUFDWixlQUFlLEVBQ2YsVUFBVSxFQUVWLFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUdMLFdBQVcsRUFJWCxTQUFTLEVBQ1QsZ0JBQWdCLEdBQ2pCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBd0IsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6RSxPQUFPLEVBQ0wsZUFBZSxFQUNmLFFBQVEsRUFDUixTQUFTLEVBQ1QsUUFBUSxFQUNSLEtBQUssRUFFTCxFQUFFLEVBQ0YsT0FBTyxFQUVQLEtBQUssR0FDTixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFaEYsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFFOUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7OztBQWU1RCxNQUFNLE9BQU8sc0JBQXNCO0lBd1ZqQyxZQUMrQixVQUFlLEVBQ2xCLFNBQWMsRUFDaEMsU0FBb0IsRUFDcEIsS0FBYSxFQUNiLEdBQXNCO1FBSkQsZUFBVSxHQUFWLFVBQVUsQ0FBSztR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R04sU0FBUztzQkFBN0IsS0FBSzt1QkFBQyxZQUFZO2dCQUdDLFVBQVU7c0JBQTdCLEtBQUs7dUJBQUMsV0FBVztnQkFHTyxhQUFhO3NCQUFyQyxLQUFLO3VCQUFDLGdCQUFnQjtnQkFLZCxVQUFVO3NCQUFsQixLQUFLO2dCQUlGLFdBQVc7c0JBRGQsS0FBSzt1QkFBQyxjQUFjO2dCQW1CakIsUUFBUTtzQkFEWCxLQUFLO3VCQUFDLFVBQVU7Z0JBZ0JiLEtBQUs7c0JBRFIsS0FBSzt1QkFBQyxnQkFBZ0I7Z0JBZW5CLE9BQU87c0JBRFYsS0FBSzt1QkFBQyxVQUFVO2dCQWtCYixRQUFRO3NCQURYLEtBQUs7dUJBQUMsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPQ1VNRU5ULCBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgZm9yd2FyZFJlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkRlc3Ryb3ksXG4gIFBMQVRGT1JNX0lELFxuICBRdWVyeUxpc3QsXG4gIFJlbmRlcmVyMixcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1xuICBCZWhhdmlvclN1YmplY3QsXG4gIGZvcmtKb2luLFxuICBmcm9tRXZlbnQsXG4gIGludGVydmFsLFxuICBtZXJnZSxcbiAgT2JzZXJ2YWJsZSxcbiAgb2YsXG4gIFN1YmplY3QsXG4gIFN1YnNjcmlwdGlvbixcbiAgdGltZXIsXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgYnVmZmVyQ291bnQsIGZpbHRlciwgc3dpdGNoTWFwLCB0YWtlVW50aWwsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTmd4SG1DYXJvdXNlbEl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL25neC1obS1jYXJvdXNlbC1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOZ3hIbUNhcm91c2VsQnJlYWtQb2ludFVwIH0gZnJvbSAnLi9uZ3gtaG0tY2Fyb3VzZWwubW9kZWwnO1xuaW1wb3J0IHsgcmVzaXplT2JzZXJ2YWJsZSB9IGZyb20gJy4vcnhqcy5vYnNlcnZhYmxlLnJlc2l6ZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25neC1obS1jYXJvdXNlbCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9uZ3gtaG0tY2Fyb3VzZWwuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9uZ3gtaG0tY2Fyb3VzZWwuY29tcG9uZW50LnNjc3MnXSxcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOZ3hIbUNhcm91c2VsQ29tcG9uZW50KSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBOZ3hIbUNhcm91c2VsQ29tcG9uZW50XG4gIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveVxue1xuICBAVmlld0NoaWxkKCdjb250YWluZXJFbG0nKSBjb250YWluZXI6IEVsZW1lbnRSZWY7XG4gIEBWaWV3Q2hpbGQoJ3ByZXYnKSBidG5QcmV2OiBFbGVtZW50UmVmO1xuICBAVmlld0NoaWxkKCduZXh0JykgYnRuTmV4dDogRWxlbWVudFJlZjtcbiAgQFZpZXdDaGlsZCgncHJvZ3Jlc3MnKSBwcm9ncmVzc0NvbnRhaW5lckVsbTogRWxlbWVudFJlZjtcblxuICAvLyBnZXQgYWxsIGl0ZW0gZWxtc1xuICBAQ29udGVudENoaWxkcmVuKE5neEhtQ2Fyb3VzZWxJdGVtRGlyZWN0aXZlLCB7XG4gICAgcmVhZDogRWxlbWVudFJlZixcbiAgICBkZXNjZW5kYW50czogdHJ1ZSxcbiAgfSlcbiAgaXRlbUVsbXM6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPjtcblxuICBAQ29udGVudENoaWxkKCdjYXJvdXNlbFByZXYnKSBjb250ZW50UHJldjogVGVtcGxhdGVSZWY8YW55PjtcbiAgQENvbnRlbnRDaGlsZCgnY2Fyb3VzZWxOZXh0JykgY29udGVudE5leHQ6IFRlbXBsYXRlUmVmPGFueT47XG4gIEBDb250ZW50Q2hpbGQoJ2Nhcm91c2VsRG90JykgZG90RWxtOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICBAQ29udGVudENoaWxkKCdjYXJvdXNlbFByb2dyZXNzJykgcHJvZ3Jlc3NFbG06IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgQENvbnRlbnRDaGlsZCgnaW5maW5pdGVDb250YWluZXInLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSlcbiAgaW5maW5pdGVDb250YWluZXI6IFZpZXdDb250YWluZXJSZWY7XG5cbiAgQENvbnRlbnRDaGlsZCgnY2Fyb3VzZWxDb250ZW50JykgY29udGVudENvbnRlbnQ6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqIHRoZSBkYXRhIHlvdSB1c2luZyB3aXRoICpuZ0ZvciwgaXQgbmVlZCB3aGVuIGluZmluaXRlIG1vZGUgb3IgYXV0b3BsYXkgbW9kZSAqL1xuICBASW5wdXQoKSBkYXRhOiBhbnlbXTtcblxuICAvKiogd2hlbiBpbmZpbml0ZSBpcyB0cnVlLCB0aGUgYW5pbWF0aW9uIHRpbWUgd2l0aCBpdGVtLCBkZWZhdWx0IGlzIDQwMC4gKi9cbiAgQElucHV0KCkgYW5pVGltZSA9IDQwMDtcblxuICAvKiogdGhpcyBjbGFzcyB3aWxsIGFkZCBpbiAjY29udGFpbmVyRWxtIHdoZW4gbW9kZWwgY2hhbmdlICovXG4gIEBJbnB1dCgpIGFuaUNsYXNzID0gJ3RyYW5zaXRpb24nO1xuXG4gIC8qKiB0aGlzIGNsYXNzIHdpbGwgYWRkIHdoZW4gY2Fyb3VzZWwgYXV0byBwbGF5LFxuICAgKiB0aGlzIGRlZmF1bHQgYXV0b3BsYXkgYW5pbWF0aW9uIGlzIHNhbWUgYXMgYW5pQ2xhc3NcbiAgICovXG4gIEBJbnB1dCgpIGFuaUNsYXNzQXV0byA9IHRoaXMuYW5pQ2xhc3M7XG5cbiAgLyoqXG4gICAqIHVzZXIgbW92ZSBwaWN0dXJlIHdpdGggdGhlIGNvbnRhaW5lciB3aWR0aCByYXRlLFxuICAgKiB3aGVuIG1vcmUgdGhhbiB0aGF0IHJhdGUsIGl0IHdpbGwgZ28gdG8gbmV4dCBvciBwcmV2LFxuICAgKiBzZXQgZmFsc2Ugd2lsbCBuZXZlciBtb3ZlIHdpdGggZGlzdGFuY2UgcmF0ZSxcbiAgICogZGVmYXVsdCBpcyBgMC4xNWBcbiAgICovXG4gIEBJbnB1dCgncGFuLWJvdW5kYXJ5JykgcGFuQm91bmRhcnk6IG51bWJlciB8IGZhbHNlID0gMC4xNTtcblxuICAvKiogd2hlbiBgc2hvdy1udW1gIGlzIGJpZ2dlciB0aGFuIDEsIHRoZSBmaXJzdCBpdGVtIGFsaWduLCBkZWZhdWx0IGlzIGBjZW50ZXJgICovXG4gIEBJbnB1dCgpIGFsaWduOiAnbGVmdCcgfCAnY2VudGVyJyB8ICdyaWdodCcgPSAnY2VudGVyJztcblxuICAvKipcbiAgICogZGlzYWJsZSB3aGVuIGRyYWcgb2NjdXIgdGhlIGNoaWxkIGVsZW1lbnQgd2lsbCBmb2xsb3cgdG91Y2ggcG9pbnQuXG4gICAqIGRlZmF1bHQgaXMgYGZhbHNlYFxuICAgKi9cbiAgQElucHV0KCdub3QtZm9sbG93LXBhbicpIG5vdERyYWcgPSBmYWxzZTtcblxuICAvKipcbiAgICogdGhlIGV2ZW50IGJpbmRpbmcgc3RhdGUgZm9yIHN0b3AgYXV0byBwbGF5IHdoZW4gbW91c2UgbW92ZW92ZXJcbiAgICovXG4gIEBJbnB1dCgnbW91c2UtZW5hYmxlJykgbW91c2VFbmFibGUgPSBmYWxzZTtcblxuICAvKiogZWFjaCBhdXRvIHBsYXkgYmV0d2VlbiB0aW1lICovXG4gIEBJbnB1dCgnYmV0d2Vlbi1kZWxheScpIGRlbGF5ID0gODAwMDtcblxuICAvKiogYXV0byBwbGF5IGRpcmVjdGlvbiwgZGVmYXVsdCBpcyBgcmlnaHRgLiAqL1xuICBASW5wdXQoJ2F1dG9wbGF5LWRpcmVjdGlvbicpIGRpcmVjdGlvbjogJ2xlZnQnIHwgJ3JpZ2h0JyA9ICdyaWdodCc7XG5cbiAgLyoqIGhvdyBtYW55IG51bWJlciB3aXRoIGVhY2ggc2Nyb2xsLCBkZWZhdWx0IGlzIGAxYC4gKi9cbiAgQElucHV0KCdzY3JvbGwtbnVtJykgc2Nyb2xsTnVtID0gMTtcblxuICAvKiogQ291bGQgdXNlciBzY3JvbGwgbWFueSBpdGVtIG9uY2UsIHNpbXVsYXRlIHdpdGggc2Nyb2xsYmFyLCBkZWZhdWx0IGlzIGBmYWxzZWAgKi9cbiAgQElucHV0KCdkcmFnLW1hbnknKSBpc0RyYWdNYW55ID0gZmFsc2U7XG5cbiAgLyoqIE1pbmltYWwgdmVsb2NpdHkgcmVxdWlyZWQgYmVmb3JlIHJlY29nbml6aW5nLCB1bml0IGlzIGluIHB4IHBlciBtcywgZGVmYXVsdCBgMC4zYCAqL1xuICBASW5wdXQoJ3N3aXBlLXZlbG9jaXR5Jykgc3dpcGVWZWxvY2l0eSA9IDAuMztcblxuICAvKipcbiAgICogc3dpdGNoIHNob3cgbnVtYmVyIHdpdGggY3VzdG9tIGxvZ2ljIGxpa2UgY3NzIEBtZWRpYSAobWluLXdpZHRoOiBgbnVtYmVyYHB4KVxuICAgKi9cbiAgQElucHV0KCkgYnJlYWtwb2ludDogTmd4SG1DYXJvdXNlbEJyZWFrUG9pbnRVcFtdID0gW107XG5cbiAgLyoqIGRpc2FibGUgZHJhZyBldmVudCB3aXRoIHRvdWNoIGFuZCBtb3VzZSBwYW4gbW92aW5nLCBkZWZhdWx0IGlzIGBmYWxzZWAgKi9cbiAgQElucHV0KCdkaXNhYmxlLWRyYWcnKVxuICBnZXQgZGlzYWJsZURyYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVEcmFnO1xuICB9XG4gIHNldCBkaXNhYmxlRHJhZyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnJvb3RFbG0pIHtcbiAgICAgIGlmICh0aGlzLl9kaXNhYmxlRHJhZyAhPT0gdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95SGFtbWVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oYW1tZXIgPSB0aGlzLmJpbmRIYW1tZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9kaXNhYmxlRHJhZyA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIGlzIHRoZSBjYXJvdXNlbCBjYW4gbW92ZSBpbmZpbml0ZSAqL1xuICBASW5wdXQoJ2luZmluaXRlJylcbiAgZ2V0IGluZmluaXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmZpbml0ZTtcbiAgfVxuICBzZXQgaW5maW5pdGUodmFsdWUpIHtcbiAgICB0aGlzLl9pbmZpbml0ZSA9IHZhbHVlO1xuXG4gICAgdGhpcy5pbmZpbml0ZUVsbVJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICB0aGlzLmFkZFN0eWxlKHJlZi5yb290Tm9kZXNbMF0sIHtcbiAgICAgICAgdmlzaWJpbGl0eTogdGhpcy5ydW5Mb29wID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBhdXRvIHBsYXkgc3BlZWQgKi9cbiAgQElucHV0KCdhdXRvcGxheS1zcGVlZCcpXG4gIGdldCBzcGVlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGVlZENoYW5nZS52YWx1ZTtcbiAgfVxuICBzZXQgc3BlZWQodmFsdWUpIHtcbiAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgIHRoaXMuc3BlZWRDaGFuZ2UubmV4dCh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogaG93IG1hbnkgbnVtYmVyIGl0ZW1zIHRvIHNob3cgb25jZSwgZGVmYXVsdCBpcyBgMWBcbiAgICogc2V0IGBhdXRvYCB0byB1c2luZyBgW2JyZWFrcG9pbnRdYCBzZXQgdmFsdWUuXG4gICAqL1xuICBASW5wdXQoJ3Nob3ctbnVtJylcbiAgZ2V0IHNob3dOdW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nob3dOdW07XG4gIH1cbiAgc2V0IHNob3dOdW0odmFsdWU6IG51bWJlciB8ICdhdXRvJykge1xuICAgIGlmICh2YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICB0aGlzLmlzQXV0b051bSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Nob3dOdW0gPSArdmFsdWU7XG4gICAgICBpZiAodGhpcy5yb290RWxtKSB7XG4gICAgICAgIHRoaXMuc2V0Vmlld1dpZHRoKCk7XG4gICAgICAgIHRoaXMucmVTZXRBbGlnbkRpc3RhbmNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIGlzIHRoYXQgY2Fyb3VzZWwgYXV0byBwbGF5ICovXG4gIEBJbnB1dCgnYXV0b3BsYXknKVxuICBnZXQgYXV0b3BsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9wbGF5O1xuICB9XG4gIHNldCBhdXRvcGxheSh2YWx1ZSkge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICBpZiAodGhpcy5lbG1zKSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NXaWR0aCA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb05leHRTdWIkID0gdGhpcy5kb05leHQuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuZG9OZXh0U3ViJCkge1xuICAgICAgICAgICAgdGhpcy5kb05leHRTdWIkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2F1dG9wbGF5ID0gdmFsdWU7XG4gICAgLy8gaWYgc2V0IGF1dG9wbGF5LCB0aGVuIHRoZSBpbmZpbml0ZSBpcyB0cnVlXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLl90bXBJbmZpbml0ZSA9IHRoaXMuaW5maW5pdGU7XG4gICAgICB0aGlzLmluZmluaXRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbmZpbml0ZSA9IHRoaXMuX3RtcEluZmluaXRlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBjdXJyZW50SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRJbmRleDtcbiAgfVxuICBzZXQgY3VycmVudEluZGV4KHZhbHVlKSB7XG4gICAgLy8gaWYgbm93IGluZGV4IGlzIG5vdCBlcXVhbCB0byBzYXZlIGluZGV4LCBkbyBzb21ldGhpbmdcbiAgICBpZiAodGhpcy5jdXJyZW50SW5kZXggIT09IHZhbHVlKSB7XG4gICAgICAvLyBpZiB0aGUgdmFsdWUgaXMgbm90IGNvbnRhaW4gd2l0aCB0aGUgYm91bmRhcnkgbm90IGhhbmRsZXJcbiAgICAgIGlmICghdGhpcy5ydW5Mb29wICYmICEoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB0aGlzLml0ZW1FbG1zLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMuZWxtcykge1xuICAgICAgICBpZiAodGhpcy5hdXRvcGxheSAmJiAhdGhpcy5pc0Zyb21BdXRvKSB7XG4gICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0b3BFdmVudC5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxSZXN0YXJ0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmF3Vmlldyh0aGlzLmN1cnJlbnRJbmRleCwgdGhpcy5oYXNJbml0V3JpdGVWYWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ01hbnkpIHtcbiAgICAgICAgICB0aGlzLmhhc0luaXRXcml0ZVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAwIDw9IHRoaXMuY3VycmVudEluZGV4ICYmXG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4IDw9IHRoaXMuaXRlbUVsbXMubGVuZ3RoIC0gMVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMuY3VycmVudEluZGV4KTtcbiAgICAgICAgICB0aGlzLl9jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmlzRnJvbUF1dG8gPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBwcm9ncmVzc1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9ncmVzc1dpZHRoO1xuICB9XG4gIHNldCBwcm9ncmVzc1dpZHRoKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NFbG0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmF1dG9wbGF5KSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc1dpZHRoID0gdmFsdWU7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShcbiAgICAgICAgKHRoaXMucHJvZ3Jlc3NDb250YWluZXJFbG0ubmF0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuY2hpbGRyZW5bMF0sXG4gICAgICAgICd3aWR0aCcsXG4gICAgICAgIGAke3RoaXMucHJvZ3Jlc3NXaWR0aH0lYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGdyYWJiaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9ncmFiYmluZztcbiAgfVxuICBzZXQgZ3JhYmJpbmcodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5fZ3JhYmJpbmcgIT09IHZhbHVlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2dyYWJiaW5nID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuY29udGFpbmVyRWxtLCAnZ3JhYmJpbmcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhbkNvdW50ID0gMDtcbiAgICAgICAgICB0aGlzLmNhbGxSZXN0YXJ0KCk7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5jb250YWluZXJFbG0sICdncmFiYmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NkLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIHVzaW5nIGZvciBjaGVjayBtb3VzZSBvciB0b3VjaGVuZFxuICBsZWF2ZU9icyQgPSBtZXJnZShcbiAgICBmcm9tRXZlbnQodGhpcy5fZG9jdW1lbnQsICdtb3VzZXVwJyksXG4gICAgZnJvbUV2ZW50KHRoaXMuX2RvY3VtZW50LCAndG91Y2hlbmQnKSxcbiAgKS5waXBlKFxuICAgIHRhcCgoZTogRXZlbnQpID0+IHtcbiAgICAgIHRoaXMuZ3JhYmJpbmcgPSBmYWxzZTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSksXG4gICk7XG5cbiAgcHJpdmF0ZSBzZXQgbGVmdCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICB0aGlzLmNvbnRhaW5lckVsbSxcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgIGB0cmFuc2xhdGVYKCR7dmFsdWV9cHgpYCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICB0aGlzLmNvbnRhaW5lckVsbSxcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgIGB0cmFuc2xhdGVYKCR7dmFsdWV9JSlgLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldCBtYXhSaWdodEluZGV4KCkge1xuICAgIGxldCBhZGRJbmRleCA9IDA7XG4gICAgc3dpdGNoICh0aGlzLmFsaWduKSB7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgYWRkSW5kZXggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGFkZEluZGV4ID0gKHRoaXMuc2hvd051bSBhcyBudW1iZXIpIC0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGFkZEluZGV4ID0gKHRoaXMuc2hvd051bSBhcyBudW1iZXIpIC0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLml0ZW1FbG1zLmxlbmd0aCAtIDEgLSB0aGlzLl9zaG93TnVtICsgMSArIGFkZEluZGV4O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgcnVuTG9vcCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRvcGxheSB8fCB0aGlzLmluZmluaXRlO1xuICB9XG4gIHByaXZhdGUgZ2V0IGxlbmd0aE9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtRWxtcy5sZW5ndGggPT09IDE7XG4gIH1cblxuICBwcml2YXRlIGdldCByb290RWxtV2lkdGgoKSB7XG4gICAgcmV0dXJuIGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZClcbiAgICAgID8gdGhpcy5yb290RWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXG4gICAgICA6IDEwMDtcbiAgfVxuXG4gIHByaXZhdGUgc2V0IGNvbnRhaW5lckVsbVdpZHRoKHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLnNldFN0eWxlKHRoaXMuY29udGFpbmVyRWxtLCAnd2lkdGgnLCB2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGlzRnJvbUF1dG8gPSB0cnVlO1xuICBwcml2YXRlIGlzQXV0b051bSA9IGZhbHNlO1xuICBwcml2YXRlIG1vdXNlT25Db250YWluZXIgPSBmYWxzZTtcbiAgcHJpdmF0ZSBhbGlnbkRpc3RhbmNlID0gMDtcbiAgcHJpdmF0ZSBlbG1XaWR0aCA9IDA7XG5cbiAgcHJpdmF0ZSByb290RWxtOiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSBjb250YWluZXJFbG06IEhUTUxFbGVtZW50O1xuXG4gIHByaXZhdGUgZWxtczogQXJyYXk8SFRNTEVsZW1lbnQ+O1xuICBwcml2YXRlIGluZmluaXRlRWxtUmVmczogQXJyYXk8RW1iZWRkZWRWaWV3UmVmPGFueT4+ID0gW107XG5cbiAgcHJpdmF0ZSBoYW1tZXI6IEhhbW1lck1hbmFnZXI7XG5cbiAgcHJpdmF0ZSBzYXZlVGltZU91dDogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIGRvTmV4dFN1YiQ6IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBkb05leHQ6IE9ic2VydmFibGU8YW55PjtcblxuICBwcml2YXRlIHJlc3RhcnQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGFueT4obnVsbCk7XG4gIHByaXZhdGUgc3BlZWRDaGFuZ2UgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KDUwMDApO1xuICBwcml2YXRlIHN0b3BFdmVudCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICBwcml2YXRlIF9wcm9ncmVzc1dpZHRoID0gMDtcbiAgcHJpdmF0ZSBfY3VycmVudEluZGV4ID0gMDtcbiAgcHJpdmF0ZSBfc2hvd051bSA9IDE7XG4gIHByaXZhdGUgX2F1dG9wbGF5ID0gZmFsc2U7XG4gIHByaXZhdGUgX2luZmluaXRlID0gZmFsc2U7XG4gIHByaXZhdGUgX3RtcEluZmluaXRlID0gZmFsc2U7XG4gIHByaXZhdGUgX2dyYWJiaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgX2Rpc2FibGVEcmFnID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBwYW5Db3VudCA9IDA7XG5cbiAgLy8gdGhpcyB2YXJpYWJsZSB1c2UgZm9yIGNoZWNrIHRoZSBpbml0IHZhbHVlIGlzIHdyaXRlIHdpdGggbmdNb2RlbCxcbiAgLy8gd2hlbiBpbml0IGZpcnN0LCBub3Qgc2V0IHdpdGggYW5pbWF0aW9uXG4gIHByaXZhdGUgaGFzSW5pdFdyaXRlVmFsdWUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IGFueSxcbiAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55LFxuICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBfem9uZTogTmdab25lLFxuICAgIHByaXZhdGUgX2NkOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgKSB7fVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLnJvb3RFbG0gPSB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50O1xuICAgIHRoaXMuY29udGFpbmVyRWxtID0gdGhpcy5yb290RWxtLmNoaWxkcmVuWzBdIGFzIEhUTUxFbGVtZW50O1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICBmb3JrSm9pbihbXG4gICAgICB0aGlzLmJpbmRDbGljaygpLFxuICAgICAgLy8gd2hlbiBpdGVtIGNoYW5nZWQsIHJlbW92ZSBvbGQgaGFtbWVyIGJpbmRpbmcsIGFuZCByZXNldCB3aWR0aFxuICAgICAgdGhpcy5pdGVtRWxtcy5jaGFuZ2VzLnBpcGUoXG4gICAgICAgIC8vIGRldGVjdENoYW5nZXMgdG8gY2hhbmdlIHZpZXcgZG90c1xuICAgICAgICB0YXAoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRJbmRleCA+IHRoaXMuaXRlbUVsbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgLy8gaSBjYW4ndCBwYXNzIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIGNoZWNrLCBvbmx5IHRoZSB3YXkgdG8gdXNpbmcgdGltZW91dC4gOihcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IHRoaXMuaXRlbUVsbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUluZmluaXRlRWxtKCk7XG4gICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgdGhpcy5wcm9ncmVzc1dpZHRoID0gMDtcbiAgICAgICAgfSksXG4gICAgICAgIHRhcCgoKSA9PiB0aGlzLl9jZC5kZXRlY3RDaGFuZ2VzKCkpLFxuICAgICAgKSxcbiAgICAgIHJlc2l6ZU9ic2VydmFibGUodGhpcy5yb290RWxtLCAoKSA9PiB0aGlzLmNvbnRhaW5lclJlc2l6ZSgpKSxcbiAgICBdKVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgLnN1YnNjcmliZSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgdGhpcy5kZXN0cm95JC51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgaWYgKHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IHZhbHVlO1xuICAgICAgdGhpcy5oYXNJbml0V3JpdGVWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKHZhbHVlOiBhbnkpID0+IGFueSkge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiBhbnkpIHtcbiAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkNoYW5nZSA9IChfOiBhbnkpID0+IHt9O1xuICBwcml2YXRlIG9uVG91Y2hlZCA9ICgpID0+IHt9O1xuXG4gIHByaXZhdGUgaW5pdCgpIHtcbiAgICB0aGlzLmluaXRWYXJpYWJsZSgpO1xuICAgIHRoaXMuc2V0Vmlld1dpZHRoKHRydWUpO1xuICAgIHRoaXMucmVTZXRBbGlnbkRpc3RhbmNlKCk7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVEcmFnKSB7XG4gICAgICB0aGlzLmhhbW1lciA9IHRoaXMuYmluZEhhbW1lcigpO1xuICAgIH1cbiAgICB0aGlzLmRyYXdWaWV3KHRoaXMuY3VycmVudEluZGV4LCBmYWxzZSk7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkgJiYgdGhpcy5ydW5Mb29wKSB7XG4gICAgICB0aGlzLmFkZEluZmluaXRlRWxtKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUhhbW1lcigpO1xuXG4gICAgaWYgKHRoaXMuYXV0b3BsYXkpIHtcbiAgICAgIHRoaXMuZG9OZXh0U3ViJC51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGVzdHJveUhhbW1lcigpIHtcbiAgICBpZiAodGhpcy5oYW1tZXIpIHtcbiAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFkZEluZmluaXRlRWxtKCkge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMuc2hvd051bTsgaSsrKSB7XG4gICAgICBjb25zdCBlbG0gPSB0aGlzLmluZmluaXRlQ29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhcbiAgICAgICAgdGhpcy5jb250ZW50Q29udGVudCxcbiAgICAgICAge1xuICAgICAgICAgICRpbXBsaWNpdDogdGhpcy5kYXRhW3RoaXMuaXRlbUVsbXMubGVuZ3RoIC0gaV0sXG4gICAgICAgICAgaW5kZXg6IHRoaXMuaXRlbUVsbXMubGVuZ3RoIC0gaSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICB0aGlzLmFkZFN0eWxlKGVsbS5yb290Tm9kZXNbMF0sIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIC8vIGJveFNoYWRvdzogYDAgMCAwIDUwMDBweCByZ2JhKDIwMCwgNzUsIDc1LCAwLjUpIGluc2V0YCxcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgtJHsxMDAgKiBpfSUpYCxcbiAgICAgICAgdmlzaWJpbGl0eTogdGhpcy5ydW5Mb29wID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0U3R5bGUoZWxtLnJvb3ROb2Rlc1swXSwgJ3dpZHRoJywgdGhpcy5lbG1XaWR0aCk7XG5cbiAgICAgIGNvbnN0IGVsbTIgPSB0aGlzLmluZmluaXRlQ29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhcbiAgICAgICAgdGhpcy5jb250ZW50Q29udGVudCxcbiAgICAgICAge1xuICAgICAgICAgICRpbXBsaWNpdDogdGhpcy5kYXRhW2kgLSAxXSxcbiAgICAgICAgICBpbmRleDogaSAtIDEsXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgdGhpcy5hZGRTdHlsZShlbG0yLnJvb3ROb2Rlc1swXSwge1xuICAgICAgICAvLyBib3hTaGFkb3c6IGAwIDAgMCA1MDAwcHggcmdiYSgyMDAsIDc1LCA3NSwgMC41KSBpbnNldGAsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7MTAwICogaX0lKWAsXG4gICAgICAgIHZpc2liaWxpdHk6IHRoaXMucnVuTG9vcCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLFxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0eWxlKGVsbTIucm9vdE5vZGVzWzBdLCAnd2lkdGgnLCB0aGlzLmVsbVdpZHRoKTtcblxuICAgICAgZWxtLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIGVsbTIuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgICB0aGlzLmluZmluaXRlRWxtUmVmcy5wdXNoKGVsbSk7XG4gICAgICB0aGlzLmluZmluaXRlRWxtUmVmcy5wdXNoKGVsbTIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlSW5maW5pdGVFbG0oKSB7XG4gICAgdGhpcy5pbmZpbml0ZUVsbVJlZnMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgYS5kZXRhY2goKTtcbiAgICAgIGEuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmluZmluaXRlQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLmluZmluaXRlQ29udGFpbmVyLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuaW5maW5pdGVFbG1SZWZzID0gW107XG4gIH1cblxuICBwcml2YXRlIGNvbnRhaW5lclJlc2l6ZSgpIHtcbiAgICB0aGlzLnNldFZpZXdXaWR0aCgpO1xuICAgIHRoaXMucmVTZXRBbGlnbkRpc3RhbmNlKCk7XG5cbiAgICBjb25zdCB0b3VjaEVuZCA9IHRoaXMuc2hvd051bSA+PSB0aGlzLmVsbXMubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuYWxpZ24gIT09ICdjZW50ZXInICYmIHRvdWNoRW5kKSB7XG4gICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3Vmlldyh0aGlzLmN1cnJlbnRJbmRleCwgZmFsc2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0VmFyaWFibGUoKSB7XG4gICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICB0aGlzLmVsbXMgPSB0aGlzLml0ZW1FbG1zLnRvQXJyYXkoKS5tYXAoKHgpID0+IHgubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgIGxldCBzdGFydEV2ZW50ID0gdGhpcy5yZXN0YXJ0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgbGV0IHN0b3BFdmVudCA9IHRoaXMuc3RvcEV2ZW50LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgaWYgKHRoaXMubW91c2VFbmFibGUpIHtcbiAgICAgICAgc3RhcnRFdmVudCA9IG1lcmdlKFxuICAgICAgICAgIHN0YXJ0RXZlbnQsXG4gICAgICAgICAgZnJvbUV2ZW50KHRoaXMuY29udGFpbmVyRWxtLCAnbW91c2VsZWF2ZScpLnBpcGUoXG4gICAgICAgICAgICAvLyB3aGVuIGxlYXZlLCB3ZSBzaG91bGQgcmV2ZXJzZSBncmFiYmluZyBzdGF0ZSB0byBzZXQgdGhlIG1vdXNlT24gc3RhdGUsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdoZW4gdGhlIGdyYWJiaW5nLCB0aGUgbWFzayB3aWxsIG9uLCBhbmQgaXQgd2lsbCBvY2N1ciBsZWF2ZSBhZ2FpblxuICAgICAgICAgICAgZmlsdGVyKCgpID0+ICF0aGlzLmdyYWJiaW5nKSxcbiAgICAgICAgICAgIHRhcCgoKSA9PiAodGhpcy5tb3VzZU9uQ29udGFpbmVyID0gZmFsc2UpKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgICBzdG9wRXZlbnQgPSBtZXJnZShcbiAgICAgICAgICBzdG9wRXZlbnQsXG4gICAgICAgICAgZnJvbUV2ZW50KHRoaXMuY29udGFpbmVyRWxtLCAnbW91c2VvdmVyJykucGlwZShcbiAgICAgICAgICAgIHRhcCgoKSA9PiAodGhpcy5tb3VzZU9uQ29udGFpbmVyID0gdHJ1ZSkpLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZG9OZXh0ID0gc3RhcnRFdmVudC5waXBlKFxuICAgICAgICAvLyBub3QgdXNpbmcgZGVib3VuY2VUaW1lLCBpdCB3aWxsIHN0b3AgbW91c2VvdmVyIGV2ZW50IGRldGVjdCwgd2lsbCBjYXVzZSBtb3VzZS1lbmFibGUgZXJyb3JcbiAgICAgICAgLy8gZGVib3VuY2VUaW1lKHRoaXMuZGVsYXkpLFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT4gdGhpcy5zcGVlZENoYW5nZSksXG4gICAgICAgIHN3aXRjaE1hcCgoKSA9PlxuICAgICAgICAgIHRpbWVyKHRoaXMuZGVsYXkpLnBpcGUoXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKCkgPT4gdGhpcy5ydW5Qcm9ncmVzcygyMCkpLFxuICAgICAgICAgICAgdGFwKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5pc0Zyb21BdXRvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ25leHQnKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCAtPSB0aGlzLnNjcm9sbE51bTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCArPSB0aGlzLnNjcm9sbE51bTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0YWtlVW50aWwoc3RvcEV2ZW50LnBpcGUodGFwKCgpID0+ICh0aGlzLnByb2dyZXNzV2lkdGggPSAwKSkpKSxcbiAgICAgICAgICApLFxuICAgICAgICApLFxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMuYXV0b3BsYXkpIHtcbiAgICAgICAgdGhpcy5kb05leHRTdWIkID0gdGhpcy5kb05leHQuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHJlU2V0QWxpZ25EaXN0YW5jZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYWxpZ24pIHtcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHRoaXMuYWxpZ25EaXN0YW5jZSA9ICh0aGlzLnJvb3RFbG1XaWR0aCAtIHRoaXMuZWxtV2lkdGgpIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgdGhpcy5hbGlnbkRpc3RhbmNlID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIHRoaXMuYWxpZ25EaXN0YW5jZSA9IHRoaXMucm9vdEVsbVdpZHRoIC0gdGhpcy5lbG1XaWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRWaWV3V2lkdGgoaXNJbml0PzogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLmlzQXV0b051bSkge1xuICAgICAgdGhpcy5fc2hvd051bSA9IHRoaXMuZ2V0QXV0b051bSgpO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lckVsbSwgJ2dyYWInKTtcbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICAvLyByZW1haW4gb25lIGVsbSBoZWlnaHRcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKFxuICAgICAgICB0aGlzLmNvbnRhaW5lckVsbSxcbiAgICAgICAgJ25neC1obS1jYXJvdXNlbC1kaXNwbGF5LW5vd3JhcCcsXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVsbVdpZHRoID0gdGhpcy5yb290RWxtV2lkdGggLyB0aGlzLl9zaG93TnVtO1xuXG4gICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3MoXG4gICAgICB0aGlzLmNvbnRhaW5lckVsbSxcbiAgICAgICduZ3gtaG0tY2Fyb3VzZWwtZGlzcGxheS1ub3dyYXAnLFxuICAgICk7XG5cbiAgICB0aGlzLmNvbnRhaW5lckVsbVdpZHRoID0gdGhpcy5lbG1XaWR0aCAqIHRoaXMuZWxtcy5sZW5ndGg7XG5cbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmNvbnRhaW5lckVsbSwgJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XG5cbiAgICB0aGlzLmluZmluaXRlRWxtUmVmcy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgIHRoaXMuc2V0U3R5bGUocmVmLnJvb3ROb2Rlc1swXSwgJ3dpZHRoJywgdGhpcy5lbG1XaWR0aCk7XG4gICAgfSk7XG4gICAgdGhpcy5lbG1zLmZvckVhY2goKGVsbTogSFRNTEVsZW1lbnQpID0+IHtcbiAgICAgIHRoaXMuc2V0U3R5bGUoZWxtLCAnd2lkdGgnLCB0aGlzLmVsbVdpZHRoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYmluZEhhbW1lcigpIHtcbiAgICBpZiAoIWlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICBjb25zdCBobSA9IG5ldyBIYW1tZXIuTWFuYWdlcih0aGlzLmNvbnRhaW5lckVsbSk7XG5cbiAgICAgIGNvbnN0IHBhbiA9IG5ldyBIYW1tZXIuUGFuKHtcbiAgICAgICAgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICBobS5hZGQocGFuKTtcblxuICAgICAgaG0ub24oJ3BhbmxlZnQgcGFucmlnaHQgcGFuZW5kIHBhbmNhbmNlbCcsIChlOiBIYW1tZXJJbnB1dCkgPT4ge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhlLnR5cGUpO1xuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aE9uZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVtb3ZlQ29udGFpbmVyVHJhbnNpdGlvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLmF1dG9wbGF5KSB7XG4gICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0b3BFdmVudC5uZXh0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3BhbmxlZnQnOlxuICAgICAgICAgIGNhc2UgJ3BhbnJpZ2h0JzpcbiAgICAgICAgICAgIHRoaXMucGFuQ291bnQrKztcbiAgICAgICAgICAgIC8vIG9ubHkgd2hlbiBwYW5tb3ZlIG1vcmUgdGhhbiB0d28gdGltZXMsIHNldCBtb3ZlXG4gICAgICAgICAgICBpZiAodGhpcy5wYW5Db3VudCA8IDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmdyYWJiaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFdoZW4gc2hvdy1udW0gaXMgYmlnZ2VyIHRoYW4gbGVuZ3RoLCBzdG9wIGhhbW1lclxuICAgICAgICAgICAgaWYgKHRoaXMuYWxpZ24gIT09ICdjZW50ZXInICYmIHRoaXMuc2hvd051bSA+PSB0aGlzLmVsbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGFtbWVyLnN0b3AodHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNsb3cgZG93biBhdCB0aGUgZmlyc3QgYW5kIGxhc3QgcGFuZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5ydW5Mb29wICYmIHRoaXMub3V0T2ZCb3VuZChlLnR5cGUpKSB7XG4gICAgICAgICAgICAgIGUuZGVsdGFYICo9IDAuMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLm5vdERyYWcpIHtcbiAgICAgICAgICAgICAgdGhpcy5sZWZ0ID1cbiAgICAgICAgICAgICAgICAtdGhpcy5jdXJyZW50SW5kZXggKiB0aGlzLmVsbVdpZHRoICtcbiAgICAgICAgICAgICAgICB0aGlzLmFsaWduRGlzdGFuY2UgK1xuICAgICAgICAgICAgICAgIGUuZGVsdGFYO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgaWYgbm90IGRyYWcgbWFueSwgd2hlbiBiaWdnZXIgdGhhbiBoYWxmXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnTWFueSkge1xuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZS5kZWx0YVgpID4gdGhpcy5lbG1XaWR0aCAqIDAuNSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmRlbHRhWCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4IC09IHRoaXMuc2Nyb2xsTnVtO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCArPSB0aGlzLnNjcm9sbE51bTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5oYW1tZXIuc3RvcCh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3BhbmNhbmNlbCc6XG4gICAgICAgICAgICB0aGlzLmRyYXdWaWV3KHRoaXMuY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncGFuZW5kJzpcbiAgICAgICAgICAgIC8vIGlmIGJvdW5kYXJ5IG1vcmUgdGhhbiByYXRlXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRoaXMucGFuQm91bmRhcnkgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgIE1hdGguYWJzKGUuZGVsdGFYKSA+IHRoaXMuZWxtV2lkdGggKiB0aGlzLnBhbkJvdW5kYXJ5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc3QgbW92ZU51bSA9IHRoaXMuaXNEcmFnTWFueVxuICAgICAgICAgICAgICAgID8gTWF0aC5jZWlsKE1hdGguYWJzKGUuZGVsdGFYKSAvIHRoaXMuZWxtV2lkdGgpXG4gICAgICAgICAgICAgICAgOiB0aGlzLnNjcm9sbE51bTtcblxuICAgICAgICAgICAgICBjb25zdCBwcmV2SW5kZXggPSB0aGlzLmN1cnJlbnRJbmRleCAtIG1vdmVOdW07XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuY3VycmVudEluZGV4ICsgbW92ZU51bTtcblxuICAgICAgICAgICAgICAvLyBpZiByaWdodFxuICAgICAgICAgICAgICBpZiAoZS5kZWx0YVggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nb1ByZXYocHJldkluZGV4KTtcbiAgICAgICAgICAgICAgICAvLyBsZWZ0XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nb05leHQobmV4dEluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS52ZWxvY2l0eVggPCAtdGhpcy5zd2lwZVZlbG9jaXR5ICYmIGUuZGlzdGFuY2UgPiAxMCkge1xuICAgICAgICAgICAgICB0aGlzLmdvTmV4dCh0aGlzLmN1cnJlbnRJbmRleCArIHRoaXMuc2Nyb2xsTnVtKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS52ZWxvY2l0eVggPiB0aGlzLnN3aXBlVmVsb2NpdHkgJiYgZS5kaXN0YW5jZSA+IDEwKSB7XG4gICAgICAgICAgICAgIHRoaXMuZ29QcmV2KHRoaXMuY3VycmVudEluZGV4IC0gdGhpcy5zY3JvbGxOdW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5kcmF3Vmlldyh0aGlzLmN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBobTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ29QcmV2KHByZXZJbmRleDogbnVtYmVyKSB7XG4gICAgaWYgKCF0aGlzLnJ1bkxvb3AgJiYgcHJldkluZGV4IDwgMCkge1xuICAgICAgcHJldkluZGV4ID0gMDtcbiAgICAgIHRoaXMuZHJhd1ZpZXcoMCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudEluZGV4ID0gcHJldkluZGV4O1xuICB9XG5cbiAgcHJpdmF0ZSBnb05leHQobmV4dEluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAoIXRoaXMucnVuTG9vcCAmJiBuZXh0SW5kZXggPiB0aGlzLm1heFJpZ2h0SW5kZXgpIHtcbiAgICAgIG5leHRJbmRleCA9IHRoaXMubWF4UmlnaHRJbmRleDtcbiAgICAgIHRoaXMuZHJhd1ZpZXcobmV4dEluZGV4KTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50SW5kZXggPSBuZXh0SW5kZXg7XG4gIH1cblxuICBwcml2YXRlIGJpbmRDbGljaygpIHtcbiAgICBpZiAodGhpcy5idG5OZXh0ICYmIHRoaXMuYnRuUHJldikge1xuICAgICAgcmV0dXJuIGZvcmtKb2luKFtcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuYnRuTmV4dC5uYXRpdmVFbGVtZW50LCAnY2xpY2snKS5waXBlKFxuICAgICAgICAgIHRhcCgoKSA9PiB0aGlzLmN1cnJlbnRJbmRleCsrKSxcbiAgICAgICAgKSxcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuYnRuUHJldi5uYXRpdmVFbGVtZW50LCAnY2xpY2snKS5waXBlKFxuICAgICAgICAgIHRhcCgoKSA9PiB0aGlzLmN1cnJlbnRJbmRleC0tKSxcbiAgICAgICAgKSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gb2YobnVsbCk7XG4gIH1cblxuICBwcml2YXRlIGNhbGxSZXN0YXJ0KCkge1xuICAgIC8vIGlmIHRoYXQgaXMgYXV0b3BsYXlcbiAgICAvLyBpZiB0aGF0IG1vdXNlIGlzIG5vdCBvbiBjb250YWluZXIoIG9ubHkgbW91c2UtZW5hYmxlIGlzIHRydWUsIHRoZSBzdGF0ZSBtYXliZSB0cnVlKVxuICAgIC8vIGlmIG5vdyBpcyBncmFiYmluZywgc2tpcCB0aGlzIHJlc3RhcnQsIHVzaW5nIGdyYWJiaW5nIGNoYW5nZSByZXN0YXJ0XG4gICAgaWYgKHRoaXMuYXV0b3BsYXkgJiYgIXRoaXMubW91c2VPbkNvbnRhaW5lciAmJiAhdGhpcy5ncmFiYmluZykge1xuICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgIHRoaXMucmVzdGFydC5uZXh0KG51bGwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkcmF3VmlldyhcbiAgICBpbmRleDogbnVtYmVyLFxuICAgIGlzQW5pbWF0aW9uID0gdHJ1ZSxcbiAgICBpc0Zyb21BdXRvID0gdGhpcy5pc0Zyb21BdXRvLFxuICApIHtcbiAgICAvLyBtb3ZlIGVsZW1lbnQgb25seSBvbiBsZW5ndGggaXMgbW9yZSB0aGFuIDFcbiAgICBpZiAodGhpcy5lbG1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ29udGFpbmVyVHJhbnNpdGlvbigpO1xuICAgICAgdGhpcy5sZWZ0ID0gLShpbmRleCAqIHRoaXMuZWxtV2lkdGggLSB0aGlzLmFsaWduRGlzdGFuY2UpO1xuXG4gICAgICBpZiAoaXNBbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGlzRnJvbUF1dG8pIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lckVsbSwgdGhpcy5hbmlDbGFzc0F1dG8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuY29udGFpbmVyRWxtLCB0aGlzLmFuaUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBpbmZpbml0ZSBtb3ZlIHRvIG5leHQgaW5kZXggd2l0aCB0aW1lb3V0XG4gICAgICAgIHRoaXMuaW5maW5pdGVIYW5kbGVyKGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5hbGlnbkRpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlQ29udGFpbmVyVHJhbnNpdGlvbigpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmNvbnRhaW5lckVsbSwgdGhpcy5hbmlDbGFzcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5jb250YWluZXJFbG0sIHRoaXMuYW5pQ2xhc3NBdXRvKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5maW5pdGVIYW5kbGVyKGluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5ydW5Mb29wKSB7XG4gICAgICBsZXQgc3RhdGUgPSAwO1xuICAgICAgc3RhdGUgPSBpbmRleCA8IDAgPyAtMSA6IHN0YXRlO1xuICAgICAgc3RhdGUgPSBpbmRleCA+IHRoaXMuaXRlbUVsbXMubGVuZ3RoIC0gMSA/IDEgOiBzdGF0ZTtcblxuICAgICAgLy8gaW5kZXggPSBpbmRleCAlIHRoaXMuX3Nob3dOdW07XG4gICAgICBpZiAoc3RhdGUgIT09IDApIHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPVxuICAgICAgICAgICAgICAodGhpcy5pdGVtRWxtcy5sZW5ndGggKyBpbmRleCkgJSB0aGlzLml0ZW1FbG1zLmxlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IGluZGV4ICUgdGhpcy5pdGVtRWxtcy5sZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzRnJvbUF1dG8gPSB0aGlzLmlzRnJvbUF1dG87XG4gICAgICAgIGlmICh0aGlzLnNhdmVUaW1lT3V0KSB7XG4gICAgICAgICAgdGhpcy5zYXZlVGltZU91dC51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zYXZlVGltZU91dCA9IHRpbWVyKHRoaXMuYW5pVGltZSlcbiAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGFueSBsb29wIGNhcm91c2VsLCB0aGUgbmV4dCBldmVudCBuZWVkIHdhaXQgdGhlIHRpbWVvdXQgY29tcGxldGVcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pVGltZSA9PT0gdGhpcy5zcGVlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29udGFpbmVyVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9XG4gICAgICAgICAgICAgICAgICAtKCh0aGlzLl9jdXJyZW50SW5kZXggLSBzdGF0ZSkgKiB0aGlzLmVsbVdpZHRoKSArXG4gICAgICAgICAgICAgICAgICB0aGlzLmFsaWduRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyKDUwKS5waXBlKFxuICAgICAgICAgICAgICAgICAgdGFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3VmlldyhcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc0luaXRXcml0ZVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGlzRnJvbUF1dG8sXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1ZpZXcodGhpcy5jdXJyZW50SW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gb2YobnVsbCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLnN0b3BFdmVudCksXG4gICAgICAgICAgKVxuICAgICAgICAgIC5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG91dE9mQm91bmQodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAncGFubGVmdCc6XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRJbmRleCA+PSB0aGlzLm1heFJpZ2h0SW5kZXg7XG4gICAgICBjYXNlICdwYW5yaWdodCc6XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRJbmRleCA8PSAwO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcnVuUHJvZ3Jlc3MoYmV0d2VlblRpbWUpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgIGNvbnN0IGhvd1RpbWVzID0gdGhpcy5zcGVlZCAvIGJldHdlZW5UaW1lO1xuICAgICAgY29uc3QgZXZlcnlJbmNyZWFzZSA9ICgxMDAgLyB0aGlzLnNwZWVkKSAqIGJldHdlZW5UaW1lO1xuICAgICAgcmV0dXJuIGludGVydmFsKGJldHdlZW5UaW1lKS5waXBlKFxuICAgICAgICB0YXAoKHQpID0+IHtcbiAgICAgICAgICB0aGlzLnByb2dyZXNzV2lkdGggPSAodCAlIGhvd1RpbWVzKSAqIGV2ZXJ5SW5jcmVhc2U7XG4gICAgICAgIH0pLFxuICAgICAgICBidWZmZXJDb3VudChNYXRoLnJvdW5kKGhvd1RpbWVzKSwgMCksXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBdXRvTnVtKCkge1xuICAgIGNvbnN0IGN1cnJXaWR0aCA9IHRoaXMucm9vdEVsbVdpZHRoO1xuICAgIC8vIGNoZWNrIHVzZXIgaGFzIGhhZCBzZXQgYnJlYWtwb2ludFxuICAgIGlmICh0aGlzLmJyZWFrcG9pbnQubGVuZ3RoID4gMCkge1xuICAgICAgLy8gZ2V0IHRoZSBsYXN0IGJpZ2dlc3QgcG9pbnRcbiAgICAgIGNvbnN0IG5vdyA9IHRoaXMuYnJlYWtwb2ludC5maW5kKChiKSA9PiB7XG4gICAgICAgIHJldHVybiBiLndpZHRoID49IGN1cnJXaWR0aDtcbiAgICAgIH0pO1xuICAgICAgLy8gaWYgZmluZCB2YWx1ZSwgaXQgaXMgY3VycmVudCB3aWR0aFxuICAgICAgaWYgKG5vdykge1xuICAgICAgICByZXR1cm4gbm93Lm51bWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmJyZWFrcG9pbnRbdGhpcy5icmVha3BvaW50Lmxlbmd0aCAtIDFdLm51bWJlcjtcbiAgICB9XG5cbiAgICAvLyBzeXN0ZW0gaW5pdCBzaG93IG51bWJlclxuICAgIGNvbnN0IGluaXROdW0gPSAzO1xuICAgIC8vIDYxMFxuICAgIGlmIChjdXJyV2lkdGggPiAzMDApIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGluaXROdW0gKyBjdXJyV2lkdGggLyAyMDApO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdE51bTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkU3R5bGUoXG4gICAgZWxtOiBIVE1MRWxlbWVudCxcbiAgICBzdHlsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfSxcbiAgKSB7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVba2V5XTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoZWxtLCBrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0U3R5bGUoZWxtOiBIVE1MRWxlbWVudCwgc3R5bGU6IHN0cmluZywgdmFsdWU6IG51bWJlcikge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShlbG0sIHN0eWxlLCBgJHt2YWx1ZX1weGApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShlbG0sIHN0eWxlLCBgJHt2YWx1ZX0lYCk7XG4gICAgfVxuICB9XG59XG4iLCI8ZGl2ICNjb250YWluZXJFbG0gY2xhc3M9XCJjYXJvdXNlbFwiPlxuICA8IS0tIG1haW4gY29udGVudCAtLT5cbiAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW25neC1obS1jYXJvdXNlbC1jb250YWluZXJdXCI+PC9uZy1jb250ZW50PlxuICA8IS0tIGxlZnQgLS0+XG4gIDxkaXYgI3ByZXYgKm5nSWY9XCJjb250ZW50UHJldlwiIGNsYXNzPVwiZGlyZWN0aW9uIGxlZnRcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29udGVudFByZXZcIj48L25nLWNvbnRhaW5lcj5cbiAgPC9kaXY+XG4gIDwhLS0gIHJpZ2h0IC0tPlxuICA8ZGl2ICNuZXh0ICpuZ0lmPVwiY29udGVudE5leHRcIiBjbGFzcz1cImRpcmVjdGlvbiByaWdodFwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb250ZW50TmV4dFwiPjwvbmctY29udGFpbmVyPlxuICA8L2Rpdj5cbiAgPCEtLSBpbmRpY2F0b3JzIC0tPlxuICA8dWwgY2xhc3M9XCJpbmRpY2F0b3JzXCIgKm5nSWY9XCJkb3RFbG1cIj5cbiAgICA8bGkgKm5nRm9yPVwibGV0IGRvdCBvZiBpdGVtRWxtczsgbGV0IGkgPSBpbmRleFwiIChjbGljayk9XCJjdXJyZW50SW5kZXggPSBpXCI+XG4gICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiXG4gICAgICAgICAgZG90RWxtO1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICRpbXBsaWNpdDoge1xuICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgY3VycmVudEluZGV4OiBjdXJyZW50SW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIFwiXG4gICAgICA+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L2xpPlxuICA8L3VsPlxuICA8IS0tIHByb2dyZXNzIC0tPlxuICA8ZGl2ICpuZ0lmPVwicHJvZ3Jlc3NFbG0gJiYgYXV0b3BsYXlcIiAjcHJvZ3Jlc3M+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInByb2dyZXNzRWxtXCI+IDwvbmctY29udGFpbmVyPlxuICA8L2Rpdj5cblxuICA8ZGl2IGNsYXNzPVwibWFza1wiICpuZ0lmPVwiZ3JhYmJpbmdcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibGVhdmVPYnMkIHwgYXN5bmNcIj48L25nLWNvbnRhaW5lcj5cbiAgPC9kaXY+XG48L2Rpdj5cbiJdfQ==